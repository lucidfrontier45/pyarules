<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- ===================================================================
  File    : relim.html
  Contents: Description of RElim program
  Author  : Christian Borgelt
==================================================================== -->
<html>
<head>
<title>RElim Documentation</title>

<style type="text/css">
body {
  min-width:   480px;
  background:  white;
  color:       black;
  font-family: sans-serif;
  font-size:   10pt;
}
tt {
  font-family: courier;
  font-size:   10pt;
}
img {
  border:      0px;
}
</style>
</head>

<!-- =============================================================== -->

<body>
<h1><a name="top">RElim</a></h1>

<h3>Find Frequent Item Sets with the RElim Algorithm
    (Recursive Elimination)</h3>

<p>Note: This documentation refers to RElim version 4.4
and may not be compatible with other versions.<br>
Call <tt>relim</tt> without any options or arguments
to check the actually supported options.</p>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3>Contents</h3>

<ul style="list-style-type:disc">
<li><a href="#intro">Introduction</a></li>
<li><a href="#notions">Basic Notions</a>
    <ul style="list-style-type:circle">
    <li><a href="#items">Items and Transactions</a></li>
    <li><a href="#suppset">Support of an Item Set</a></li>
    </ul></li>
<li><a href="#target">Target Types</a>
    <ul style="list-style-type:circle">
    <li><a href="#sets">Frequent Item Sets</a></li>
    <li><a href="#closed">Closed Item Sets</a></li>
    <li><a href="#maximal">Maximal Item Sets</a></li>
    </ul></li>
<li><a href="#invoke">Program Invocation</a></li>
<li><a href="#options">Program Options</a></li>
<li><a href="#input">Input Format</a>
    <ul style="list-style-type:circle">
    <li><a href="#transin">Format of the Transactions File</a></li>
    <li><a href="#selin">Format of the
        Item Selection/Insertion Penalties File</a></li>
    </ul></li>
<li><a href="#output">Output Format</a>
    <ul style="list-style-type:circle">
    <li><a href="#setout">Format of Frequent Item Sets</a></li>
    <li><a href="#pspout">Format of a Pattern Spectrum</a></li>
    </ul></li>
<li><a href="#copying">Copying</a></li>
<li><a href="#download">Download</a></li>
<li><a href="#contact">Contact</a></li>
<li><a href="#refs">References</a></li>
</ul>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="intro">Introduction</a></h3>

<p>RElim (<b>R</b>ecursive <b>Elim</b>imination) is a program for
frequent item set mining, a data mining method that was originally
developed for market basket analysis. Frequent item set mining aims
at finding regularities in the shopping behavior of the customers
of supermarkets, mail-order companies and online shops. In particular,
it tries to identify sets of products that are frequently bought
together. Once identified, such sets of associated products may be
used to optimize the organization of the offered products on the
shelves of a supermarket or the pages of a mail-order catalog or web
shop, may give hints which products may conveniently be bundled, or
may allow to suggest other products to customers. However, frequent
item set mining may be used for a much wider variety of tasks, which
share that one is interested in finding regularities between (nominal)
variables in a given data set. For an overview of frequent item set
mining in general and several specific algorithms, see the survey
<a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<p>This page describes the RElim implementation that I have been
developing and improving since 2005. RElim is inspired by the
<a href="http://www.borgelt.net/fpgrowth.html">FP-growth algorithm</a>,
but does its work without prefix trees or any other complicated data
structures. The main strength of this algorithm is not its speed
(although it is not slow, but even outperforms Apriori and Eclat on
some data sets), but the greater simplicity of its structure compared
to FP-growth. Basically all the work is done in one recursive function
of fairly few lines of code. RElim improves over the approach by the
<a href="http://www.borgelt.net/sam.html">SaM algorithm</a> by
exploiting the idea of bin sort (aka bucket sort or radix sort)
to group transactions with the same prefix.</p>

<p>The basic algorithmic scheme was first described in
<a href="#Borgelt_et_al_2005a">[Borgelt <i>et al.</i> 2005a]</a> and
<a href="#Borgelt_et_al_2005b">[Borgelt <i>et al.</i> 2005b]</a>,
which also cover how to find approximate frequent item sets with RElim.
The basic idea is that the transactions in the database are noisy
observations of the actual transactions, that is, a transaction may
actually contain an item even though it was not recorded in the
database. In order to handle such a situation, RElim allows an item
set to be supported by transactions that contain only part of the
items, although these transactions have a lower weight. These weights
are computed from item insertion penalties, based on what items have
to be inserted into the transaction to make it contain an item set
under consideration. Details of the approach as well as how the
algorithm needs to be modified to accommodate this can be found in
<a href="#Borgelt_et_al_2005a">[Borgelt <i>et al.</i> 2005a]</a> and
<a href="#Borgelt_et_al_2005b">[Borgelt <i>et al.</i> 2005b]</a>.</p>

<p>Note that the current version of this program can only find
frequent item sets, <i>not</i> association rules.</p>

<p>Enjoy,<br>
<a href="http://www.borgelt.net">
Christian Borgelt</a></p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="notions">Basic Notions</a></h3>

<p>This section briefly introduces some basic notions needed
to talk about frequent item sets. These notions are <i>item</i>,
<i>transaction</i>, <i>support</i> and <i>frequent</i>, <i>closed</i>
and <i>maximal item set</i>. For a more extensive coverage, consult
the survey <a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="items">Items and Transactions</a></h4>

<p>On an abstract level, the input to frequent item set mining
consists of a bag or multiset of <i>transactions</i> that are defined
over a set of <i>items</i>, sometimes called the <i>item base</i>.
These items may be products, special equipment items, service options
etc. For an abstract treatment it suffices that items have an identity,
that is, it is possible to distinguish one item from another. The item
base is the set of all considered items, for example, the set of all
products that are sold by a given supermarket, mail-order company or
online shop. Any subset of the item base is called an
<i>item set</i>.</p>

<p>A transaction is simply an item set and it represents, for example,
the set of products bought by a customer. Since two or more customers
may, in principle, buy the exact same set of products, we cannot model
the whole of all "shopping baskets" or "shopping carts" (bought, say,
in a given week) as a <i>set</i> of transactions, since in a set each
element is unique. There are several solutions to this problem: one may,
for example, model the whole of all transactions as a bag or multiset
(a generalization of a set, which allows for multiple occurrences of
the same element) or as a vector (where elements at different positions
may be the same, but are still distinguished by their position), or by
extending each transaction with a unique <i>transaction identifier</i>
(or <i>tid</i> for short; note that the position of a transaction in
a vector representation is an implicit transaction identifier). Still
another possibility consists in using a standard <i>set</i> of (unique)
transactions and assigning to each of them an occurrence counter. Here
I use the bag/multiset terminology, even though an occasional "set of
transactions" may have slipped through. (This should always be read
as "bag/multiset of transactions".)</p>

<p>Note that the item base (the set of all considered items) is often
not given explicitly, but only implicitly as the union of all given
transactions. This is also the case for my RElim program, which by
default only takes a transaction file as input. However, it is also
possible to specify the item base explicitly with an optional item
selection file (option <tt>-R</tt>; discussed in <a href="#selin">this
section</a>). This can be useful, for example, if one wants to restrict
the analysis to a subset of all items.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<hr>

<h4><a name="suppset">Support of an Item Set</a></h4>

<p>Let S be an item set and T the bag/multiset of all transactions
under consideration. Then the <i>absolute support</i> (or simply the
<i>support</i>) of the item set S is the number of transactions in T
that contain S. Likewise, the <i>relative support</i> of S is the
fraction (or percentage) of the transactions in T which contain S.</p>

<p>More formally, let S be an item set and
U&nbsp;=&nbsp;{&nbsp;X&isin;T&nbsp;|&nbsp;S&sube;t&nbsp;}
the bag/multiset of all transactions in T that have S as a subset
(i.e. contain all of the items in S and possibly some others). Then</p>

<p>supp<sub>abs</sub>(S)&nbsp;=&nbsp;|U|
&nbsp;=&nbsp;|{&nbsp;X&isin;T&nbsp;|&nbsp;S&sube;t&nbsp;}|</p>

<p>is the absolute support of S and</p>

<p>supp<sub>rel</sub>(S)&nbsp;=&nbsp;(|U|&nbsp;/&nbsp;|T|)&nbsp;*100%</p>

<p>is the relative support of S. Here |U| and |T| are the number of
elements in U and T, respectively.</p>

<p>In a supermarket setting, the item set S may be a set like
S&nbsp;=&nbsp;{&nbsp;bread, wine, cheese&nbsp;} and T may
be the bag/multiset of all "baskets" or "carts" of products bought by
the customers of a supermarket &ndash; in a given week if you like.
U is the bag/multiset of all transactions in T that contain all items
in S (and maybe also some other items). For example, if a customer
buys the set X&nbsp;=&nbsp;{&nbsp;milk, bread, apples, wine, sausages,
cheese, onions, potatoes&nbsp;}, then S is obviously a subset of X,
hence X is in U. If there are 318 customers, each giving rise to one
transaction, and 242 of these customers bought such a set X or a
similar one that contains S, while the other customers bought sets
of products that lacked at least one of the items in S, then
supp<sub>abs</sub>(S)&nbsp;=&nbsp;242 and
supp<sub>rel</sub>(S)&nbsp;=&nbsp;242/318&nbsp;=&nbsp;76.1%.</p>

<p>The goal of frequent item set mining is to find all item sets
(that is, all subsets of the item base) that occur in the given
bag/multiset of transactions with at least a user-specified
<i>minimum support</i> supp<sub>min</sub>. Such item sets are
called <i>frequent item sets</i>.</p>

<p>The default value for the minimum support in my RElim program is
10% (the percentage indicates implicitly that it refers to relative
support). This value can be changed with the option <tt>-s</tt>.
Note that the argument to this option is interpreted as a percentage
if it is positive, but if it is negative, it is interpreted as an
absolute number (number of transactions) rather than a percentage.
That is, <tt>-s20</tt> means a minimum <i>relative</i> support of
20%, while <tt>-s-20</tt> means a minimum <i>absolute</i> support
of 20 transactions.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="target">Target Types</a></h3>

<p>An annoying problem in frequent item set mining is that the number of
frequent item sets is often huge and thus the output can easily exceed
the size of the transaction database to mine. In order to mitigate this
problem, several restrictions of the set of frequent item sets have been
suggested. These restrictions are covered by the target type.</p>

<p>The target type, which can be selected via the option <tt>-t</tt>,
is either frequent item sets (default, option <tt>-ts</tt>),
closed item sets (option <tt>-tc</tt>), or maximal item sets
(option <tt>-tm</tt>).</p>

<p>More detailed information about the different target types of
frequent item set mining can be found in the survey
<a href="#Borgelt_2012">[Borgelt 2012]</a>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="sets">Frequent Item Sets (default, option -ts)</a></h4>

<p>Often one only wants to find frequent item sets. That is, one wants
to find all item sets with a support exceeding a certain threshold,
the so-called <i>minimum support</i>. For my RElim program this is
the default operation mode. However, this mode can also be selected
explicitly with the option <tt>-ts</tt>.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="closed">Closed Item Sets (option -tc)</a></h4>

<p>A frequent item set is called <i>closed</i> if no superset is
frequent, that is, has a support exceeding the minimum support.
Formally, an item set I is called closed iff</p>

<p>&forall; J &sup; I: supp(J) &lt; supp(I).</p>

<p>If the option <tt>-tc</tt> is given, the found frequent item sets
are subsequently filtered and only the closed item sets are
reported.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="maximal">Maximal Item Sets (option -tm)</a></h4>

<p>A frequent item set is called <i>maximal</i> if no superset
the same support (or, in other words, if all supersets have a lower
support). Formally, an item set I is called maximal iff</p>

<p>&forall; J &sup; I: supp(J) &lt; supp<sub>min.</sub></p>

<p>If the option <tt>-tm</tt> is given, the found frequent item sets are
subsequently filtered and only the maximal item sets are reported.</p>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="invoke">Program Invocation</a></h3>

<p>My RElim implementation is a command line program that has to be
called in a terminal or command window or from a shell script. If
double-clicked in a file manager (e.g. in Microsoft Windows), it merely
prints a usage message to a terminal/command window that is briefly
opened and immediately closed again. This does not mean that the
program does not work. In order to run the program, open a
terminal/command window, change directory to where you stored
the program, and then type an invocation command.</p>

<p>The general syntax of the program invocation is</p>

<p><tt>relim [options] infile [outfile]</tt></p>

<p>The first argument <tt>infile</tt>, which is mandatory, is the name
of a file that contains the transactions to analyze. The format of
this file is described in <a href="#transin">this section</a>. If
instead of a file name a single minus sign "<tt>-</tt>" or an empty
string <tt>""</tt> is given, the input is read from standard input
rather than from a file.</p>

<p>The second argument <tt>outfile</tt>, which is optional (as
indicated by the brackets), is the name of a file to which the found
frequent item sets are to be written. That it is optional is useful
for benchmark tests, where the time it takes to write the output to
a file can conceal the actual search time, or if only a pattern
spectrum (number of found frequent item sets collected by size and
(absolute) support; option <tt>-P</tt>) is to be found. The format
in which frequent item sets are written to the output file is described
in <a href="#setout">this section</a>. If instead of a file name a
single minus sign "<tt>-</tt>" or an empty string <tt>""</tt> is
given, the output is written to standard output rather than to a
file.</p>

<p>In addition to the input and output file several options can be
given, all of which consist of a minus sign and a single letter.
The full list of options can be found in the
<a href="#options">next section</a>.</p>

<p>Some options take a parameter. For example, the option <tt>-s</tt>,
with which the minimum support is specified, takes a number as a
parameter, which must follow the letter <tt>s</tt> without any
separating space. A space between the option character and its
parameter is only allowed if the parameter is a string, for example,
a file name. (However, even in this case the parameter may follow
the option letter directly.) If the parameter is a number or a
single letter, it must follow the option letter directly.</p>

<p>Options may be combined. For example,</p>

<p><tt>relim -s10m2n5 input output</tt></p>

<p>means that the minimum support is 10% (option <tt>-s</tt>),
the minimum number of items in an item set is 2 (option <tt>-m</tt>)
and the maximum number of items in an item set is 5
(option <tt>-n</tt>).</p>

<p>Options may be specified
anywhere on the command line, that is, before the input file name,
in between the input and output file names, or after the output
file name.</p>

<p>If an option is given more than once, the last statement counts.
That is, with</p>

<p><tt>relim -s10 -s20 input output</tt></p>

<p>the minimum support is 20%, as the <tt>-s10</tt> is overwritten
by the following <tt>-s20</tt>.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="options">Program Options</a></h3>

<p>My RElim implementation supports the following options<br>
(a <tt>#</tt> after the option letter means that the option
takes a parameter):</p>

<table border=1 cellpadding=2 cellspacing=0>
<tr><th>option</th><th>meaning</th><th>default</th></tr>
<tr><td valign="top"><tt>-t#</tt></td>
    <td>target type<br>
        <tt>s</tt>: frequent item sets<br>
        <tt>c</tt>: closed item sets<br>
        <tt>m</tt>: maximal item sets</td>
    <td valign="top"><tt>s</tt></td></tr>
<tr><td valign="top"><tt>-m#</tt></td>
    <td>minimum number of items per item set</td>
    <td valign="top">1</td></tr>
<tr><td valign="top"><tt>-n#</tt></td>
    <td>maximum number of items per item set</td>
    <td valign="top">no&nbsp;limit</td></tr>
<tr><td valign="top"><tt>-s#</tt></td>
    <td>minimum (standard) support of an item set<br>
        positive: percentage of transactions<br>
        negative: absolute number of transactions</td>
    <td valign="top">10</td></tr>
<tr><td valign="top"><tt>-S#</tt></td>
    <td>maximum support of an item set<br>
        positive: percentage of transactions<br>
        negative: absolute number of transactions</td>
    <td valign="top">100</td></tr>
<tr><td valign="top"><tt>-i#</tt></td>
    <td>minimum support with item insertions<br>
        (only with item insertions, option <tt>-u</tt>)<br>
        positive: percentage of transactions<br>
        negative: absolute number of transactions</td>
    <td valign="top">10</td></tr>
<tr><td valign="top"><tt>-N#</tt></td>
    <td>t-norm for combining item penalties<br>
        <tt>m</tt>: minimum T(a,b) = min(a,b)<br>
        <tt>n</tt>: nil-potent minimum T(a,b) = min(a,b) if a+b > 1 else 0<br>
        <tt>p</tt>: product T(a,b) = a*b<br>
        <tt>l</tt>: &#321;ukasiewicz t-norm T(a,b) = max(0,a+b-1)<br>
        <tt>h</tt>: Hamacher product T(a,b) = 0 if a = b = 0
                    else a*b/(a+b-a*b)</td>
    <td valign="top">p</td></tr>
<tr><td valign="top"><tt>-u#</tt></td>
    <td>minimum weight of a transaction<br>
        (a value >= 0 selects item insertions)</td>
    <td valign="top">-1</td></tr>
<tr><td valign="top"><tt>-e#</tt></td>
    <td>additional evaluation measure<br>
        <tt>x</tt>: no measure<br>
        <tt>b</tt>: binary logarithm of support quotient</td>
    <td valign="top">x</td></tr>
<tr><td valign="top"><tt>-d#</tt></td>
    <td>threshold for additional evaluation measure<br>
        (as a percentage)</td>
    <td valign="top">10</td></tr>
<tr><td valign="top"><tt>-q#</tt></td>
    <td>sort items w.r.t. their frequency<br>
        0: do not sort<br>
        1: ascending, -1: descending w.r.t. item frequency<br>
        2: ascending, -2: descending w.r.t. transaction size sum</td>
    <td valign="top">2</td></tr>
<tr><td valign="top"><tt>-x</tt></td>
    <td>do not prune with perfect extensions</td>
    <td valign="top">prune</td></tr>
<tr><td valign="top"><tt>-l#</tt></td>
    <td>number of items for k-items machine<br>
        (only for algorithm variants i,r,o)</td>
    <td valign="top">16</td></tr>
<tr><td valign="top"><tt>-y#</tt></td>
    <td>threshold for transaction list sorting</td>
    <td valign="top">32</td></tr>
<tr><td valign="top"><tt>-F#:#..</tt></td>
    <td>support border for filtering item sets<br>
       (list of minimum support values, one per item set size,<br>
       starting at the minimum size, as given with option <tt>-m#</tt>)</td>
    <td valign="top">none</td></tr>
<tr><td valign="top"><tt>-R#</tt></td>
    <td>read item selection/insertion penalties from a file<br>
        parameter: file name<br>
        (insertion penalities if <tt>-u</tt> is given
        with a parameter >= 0)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-P#</tt></td>
    <td>write a pattern spectrum to a file<br>
        parameter: file name</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-Z</tt></td>
    <td>print item set statistics<br>
        (number of item sets per size)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-g</tt></td>
    <td>write output in scanable form<br>
        (quote certain characters)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-h#</tt></td>
    <td>record header  for output</td>
    <td valign="top">""</td></tr>
<tr><td valign="top"><tt>-k#</tt></td>
    <td>item separator for output</td>
    <td valign="top">" "</td></tr>
<tr><td valign="top"><tt>-I#</tt></td>
    <td>implication sign for association rules</td>
    <td valign="top">" "</td></tr>
<tr><td valign="top"><tt>-v#</tt></td>
    <td>output format for item set information<br>
        (changed to "<tt> (%a)</tt>" if parameter
        of <tt>-s</tt> is negative)</td>
    <td valign="top">"<tt> (%S)</tt>"<br>
                     "<tt> (%a)</tt>"</td></tr>
<tr><td valign="top"><tt>-w</tt></td>
    <td>transaction weight in last field</td>
    <td valign="top">only items</td></tr>
<tr><td valign="top"><tt>-r#</tt></td>
    <td>record/transaction separators</td>
    <td valign="top">"<tt>\n</tt>"</td></tr>
<tr><td valign="top"><tt>-f#</tt></td>
    <td>field/item separators</td>
    <td valign="top">"<tt> \t,</tt>"</td></tr>
<tr><td valign="top"><tt>-b#</tt></td>
    <td>blank characters</td>
    <td valign="top">"<tt> \t\r</tt>"</td></tr>
<tr><td valign="top"><tt>-C#</tt></td>
    <td>comment characters</td>
    <td valign="top">"<tt>#</tt>"</td></tr>
<tr><td valign="top"><tt>-T#</tt></td>
    <td>file to write transaction identifiers to<br>
        (only with algorithm variant i)</td>
    <td valign="top"></td></tr>
<tr><td valign="top"><tt>-!</tt></td>
    <td>print additional option information</td>
    <td valign="top"></td></tr>
</table>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="input">Input Format</a></h3>

<h4><a name="transin">Format of the Transactions File</a></h4>

<p>The transactions file has to be a (text) file structured by field
and record separators and blanks. Record separators, not surprisingly,
separate records, usually lines (since the default record separator
is the newline character), field separators separate fields, usually
words (since among the default field separators are the space and the
tabulator, but also the comma). Blanks are used to fill fields, for
example, to align them. In the transactions file each record must
contain one transaction, i.e. a list of item identifiers, which are
separated by field separators. An empty record is interpreted as an
empty transaction. That is, it is counted for the total number of
transactions, but does not count for the support of any item set other
than the empty set. A transaction may contain the same item multiple
times (that is, duplicate items do not raise an error), but this
multiplicity is disregarded by the RElim program. It only considers
<i>whether</i> an item is contained in a transaction or not, <i>not</i>
how many times an item is contained in a transaction.</p>

<p>Example input files can be found in the directory <tt>relim/ex</tt>
in the source package. These files are used in the following to
demonstrate how to use the command line options <tt>-r</tt>,
<tt>-f</tt>, <tt>-b</tt> and <tt>-w</tt>. In addition, there are
several conversion scripts (for Linux/Unix), with which different
common input formats can be converted into the format required by
the RElim program.</p>

<p>In the file <tt>test1.tab</tt> transactions are separated by newline
characters (that is, each line of the file contains one transaction)
and the items of a transaction are separated by spaces. That is, the
file <tt>test1.tab</tt> looks like this:</p>

<p><tt>
a b c<br>
a d e<br>
b c d<br>
a b c d<br>
b c<br>
a b d<br>
d e<br>
a b c d<br>
c d e<br>
a b c
</tt></p>

<p>As can be seen, there are ten transactions over the item base
{a, b, c, d, e}, which contain between two and four items each.</p>

<p>The file <tt>test1.tab</tt> is in the standard input format and
hence it can be processed directly:</p>

<p><tt>relim test1.tab test1.out</tt></p>

<p>Instead of spaces, tabulators may be used, and it is possible to mix
spaces and tabulators. Note, however, that multiple consecutive white
space characters (like multiple spaces or a space and a tabulator etc.)
are interpreted as a single field separator. The reason is that by
default spaces, tabulators and the carriage return character are
interpreted as blank characters, which are removed when reading
items. Hence only the first white space character after an item is
interpreted as a field separator, all following white space characters
are interpreted as blanks.</p>

<p>Note also that commas are among the default field separators as well.
That is, if the file <tt>test1.tab</tt> looked like this:</p>

<p><tt>
a,b,c<br>
a,d,e<br>
b,c,d<br>
a,b,c,d<br>
b,c<br>
a,b,d<br>
d,e<br>
a,b,c,d<br>
c,d,e<br>
a,b,c
</tt></p>

<p>it could still be processed directly with the command stated
above. You may also mix spaces, tabulators and commas.</p>

<p>Unfortunately, though, the fact that commas are interpreted as field
separators does not necessarily mean that CSV-files (where CSV stands
for "comma separated values"), as they can be written by programs like
Microsoft Excel, can be processed directly. The reason is that in a
CSV-file all lines contain the same number of fields. That is, in
CSV-format, the above input file would look like this (file
<tt>test1.csv</tt> in directory <tt>relim/ex</tt>):</p>

<p><tt>
a,b,c,<br>
a,d,e,<br>
b,c,d,<br>
a,b,c,d<br>
b,c,,<br>
a,b,d,<br>
d,e,,<br>
a,b,c,d<br>
c,d,e,<br>
a,b,c,
</tt></p>

<p>Note the single and double commas at the end of most lines, which
separate empty fields (as these transactions have fewer items than
the longest transaction). While a single comma at the end of a line
does not cause any problems and is simply ignored, two or more commas
lead to an error message "<tt>item expected</tt>", because an item may
not be an empty string. This can be fixed by declaring the comma a
blank character (option <tt>-b</tt>). That is, the CSV-file can be
processed with:</p>

<p><tt>relim -b, test1.csv test1.out</tt></p>

<p>Note, however, that the characters given with the option <tt>-b</tt>
replace the default blank characters. So if you still need spaces to be
interpreted as blanks, they have to be specified as well:</p>

<p><tt>relim -b" ," test1.csv test1.out</tt></p>

<p>In the file <tt>test2.tab</tt> the same transactions can be found,
but several different field separators are used:</p>

<p><tt>
a,b,c<br>
a,d,e<br>
b.c.d<br>
a,b,c,d<br>
b:c<br>
a,b,d<br>
d,e<br>
a,b,c,d<br>
c;d;e<br>
a,b,c
</tt></p>

<p>The file <tt>test2.tab</tt> can be processed by declaring different
field separators with the option <tt>-f</tt>:</p>

<p><tt>relim -f",.;:" -l test2.tab test2.out</tt></p>

<p>The file <tt>test3.tab</tt> has basically the same format as the
file <tt>test1.tab</tt>, with the only difference that the last fields
of each record states an (integer) transaction weight/multiplicity.</p>

<p><tt>
a b c 2<br>
a d e 1<br>
b c d 1<br>
a b c d 2<br>
b c 1<br>
a b d 1<br>
d e 1<br>
c d e 1
</tt></p>

<p>This allows us to combine transactions, so that <tt>test2.tab</tt>
has only 8 lines, while <tt>test1.tab</tt> has 10 lines, because the
transactions <tt>a b c</tt> and <tt>a b c d</tt> occur twice. In order
to instruct the RElim program to interpret the last field of each record
as such a weight/multiplicity, is has to be invoked with the option
<tt>-w</tt>:</p>

<p><tt>relim -w test3.tab test3.out</tt></p>

<p>The files <tt>test4.tab</tt> to <tt>test6.tab</tt> are in formats
that may be common, but which cannot be processed directly with the
RElim program.</p>

<p>In the file <tt>test4.tab</tt> each line contains a transaction
identifier and an item, separated by a space (not shown because of
the large number of lines). This file can be converted (on Linux/Unix
systems) into the standard input format with the script
<tt>tid2set</tt>, i.e., with</p>

<p><tt>tid2set test4.tab x.tab</tt></p>

<p>Note that this script sorts the input file (here: <tt>test4.tab</tt>)
w.r.t. the transaction identifier, so that items belonging to the same
transaction occupy consecutive lines/records. That is, the input need
not already be sorted by transaction identifier, rather the script does
this to make sure that the conversion works.</p>

<p>In the file <tt>test5.tab</tt> the first line states the item names
and the following lines contain flags <tt>T</tt> (true) and <tt>F</tt>
(false) depending on whether the item is contained in the transaction
represented by the line or not:</p>

<p><tt>
a b c d e<br>
T T T F F<br>
T F F T T<br>
F T T T F<br>
T T T T F<br>
F T T F F<br>
T T F T F<br>
F F F T T<br>
T T T T F<br>
F F T T T<br>
T T T F F
</tt></p>

<p>This format can be converted (on Linux/Unix systems) into the
standard input format with the script <tt>flg2set</tt>, i.e., with</p>

<p><tt>flg2set test5.tab x.tab</tt></p>

<p>This script interprets <tt>T</tt>, <tt>t</tt>, and <tt>1</tt> as
"true", that is, as indicators that the item corresponding to the
column is contained in the transaction corresponding to the row,
and any other entry as "false" (the item is not contained in the
transaction).</p>

<p>In the file <tt>test6.tab</tt> there is one item per line and
transactions are separated by blank lines (not shown here because of
the large number of lines). This format can be converted (on Linux/Unix
systems) into the standard input format with the script
<tt>row2set</tt>, i.e., with:</p>

<p><tt>row2set test6.tab x.tab</tt></p>

<p>Note that the file <tt>test6.tab</tt> could be processed directly
if the transactions were not separated by a mere empty line (that is,
two newline characters following each other), but if the empty line
contained a special character, for example <tt>%</tt>. In this case
the file can be processed directly with</p>

<p><tt>relim -r"%" -f"\n" -b"\n" test6.tab x.tab</tt></p>

<p>The additional scripts <tt>tab2set</tt> and <tt>hdr2set</tt> convert
tables with column numbers or column names into a format appropriate
for the RElim program. They are invoked in the same way as all other
scripts discussed above, i.e., with</p>

<p><tt>tab2set a.tab b.tab</tt></p>

<p>or</p>

<p><tt>hdr2set a.tab b.tab</tt></p>

<p>where <tt>a.tab</tt> is the name of the input file and <tt>b.tab</tt>
the name of the output file. The script <tt>tab2set</tt> replaces each
table entry "x" of the input file by "Xi=x", where i is the column number
(starting with 1).</p>

<p>The script <tt>hdr2set</tt> reads the variable names from the first
line of the input file and then replaces each table entry "x" by "X=x",
where "X" is the variable name that was found in the corresponding
column of the first line. These scripts are handy if you want to
process tabular data by treating each table row as a transaction.</p>

<p>Note that any input may also be read from standard input and any
output may be sent to standard output, simply by specifying a
'<tt>-</tt>' or an empty string <tt>""</tt> instead of a filename.
For example (on a Linux/Unix system)</p>

<p><tt>cat test1.tab | relim - -</tt></p>

<p>reads the transactions from standard input (where they are fed by
the cat command) and writes the found frequent item sets directly to
the terminal. They may be piped to any other program or script, since
all other messages of the RElim program are written to standard
error.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<hr>

<h4><a name="selin">Format of the
    Item Selection/Insertion Penalties File</a></h4>

<p>In addition to an input file with the transactions and an output
file for the found item sets, an item selection/insertion penalties
file may be passed to the RElim program with the option <tt>-R</tt>.
Without the option <tt>-u</tt>, this file lists a selection of items
that are to be included in the search, while any items not listed in
this file are to be ignored. It can be seen as a specification of the
item base for the search.</p>

<p>The item selection file has to be a (text) file structured by the
same field and record separators and blanks as the transactions file.
Items may be listed in a single record or in multiple records; it does
not matter in which record an item occurs. All that matters is whether
an item occurs in the item selection file (then it is included in the
search) or not (then it is ignored).</p>

<p>If the option <tt>-u</tt> is given with a parameter &ge;&nbsp;0,
the file passed with the option <tt>-R</tt> is used to specify
item insertion penalties. Insertion penalties are real-valued
numbers in [0,1]. The insertion penalty is the higher, the smaller
the value, because the insertion penalties are combined with a
t-norm (to be specified with the option <tt>-N</tt>) with the
transaction weight, so that transactions which only with item
insertions can be made to support an item set contribute less to the
support of an item set. A value of&nbsp;1 means no penalty at all.
A value of&nbsp;0 means that the penalty is so high that an insertion
is impossible.</p>

<p>The first record of an item insertion penalties file, which must
have one field, contains the default insertion penalty as a real-valued
number in [0,1]. This is used for all items that are not explicitly
listed in one of the following records. The following records state
the appearance of specific items, one per record. The first field of
these records states the item, the second the insertion penalty as a
real-valued number in [0,1].</p>

<p><b>Example 1:</b>
Allow only items <tt>a</tt> and <tt>b</tt> to be inserted, each
with a penalty of 0.5.</p>
<p><tt>0<br>
       a 0.5<br>
       b 0.5</tt></p>

<p><b>Example 2:</b>
Any item may be inserted with a penalty of 0.8, except <tt>a</tt>
and <tt>b</tt>, which may not be inserted, and item <tt>c</tt>,
which carries the more severe insertion penalty of 0.6.</p>
<p><tt>0.8<br>
       a 0<br>
       b 0<br>
       c 0.6</tt></p>

<p>Providing no item insertion penalties file (if the option <tt>-u</tt>
is given) is equivalent to an item insertion penalties file containing
only a default insertion penalty of 0, which does not allow any item to
be inserted.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="output">Output Format</a></h3>

<p>The output format for item sets is fairly flexible. Especially
the output of the additional information about item sets (support,
additional evaluation) can be formatted freely.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="setout">Format of Frequent Item Sets</a></h4>

<p>Each line of the output file contains one item set in the format</p>

<p><tt>A&nbsp;B&nbsp;C&nbsp;[...]&nbsp;&lt;add.&nbsp;info&gt;</tt></p>

<p>where A, B and C are item identifiers, and
<tt>&lt;add.&nbsp;info&gt;</tt>
is determined by the additional information output format (option
<tt>-v</tt>). The item separator may be changed with the option
<tt>-k</tt>. For example,</p>

<p><tt>relim -k, test1.tab test.out</tt></p>

<p>produces output in the format</p>

<p><tt>A,B,C,[...]&nbsp;&lt;add.&nbsp;info&gt;</tt></p>

<p>Each output line may be preceded by a string that is specified
with the option <tt>-h</tt> (record header for output).</p>

<p>The output format for the additional rule information can be any
string with the following special format symbols (similar to the
style of the special format symbols of the <tt>printf</tt> function
in the programming language C):</p>

<table border=0 cellpadding=0 cellspacing=0>
<tr><td>%%</td><td style="width:16px"></td>
    <td>a percent sign</td></tr>
<tr><td>%i</td><td></td>
    <td>number of items (item set size)</td></tr>
<tr><td>%a</td><td></td>
    <td>absolute item set support</td></tr>
<tr><td>%s</td><td></td>
    <td>relative item set support as a fraction</td></tr>
<tr><td>%S</td><td></td>
    <td>relative item set support as a percentage</td></tr>
<tr><td>%w</td><td></td>
    <td>absolute support with insertions</td></tr>
<tr><td>%r</td><td></td>
    <td>relative support with insertions as a fraction</td></tr>
<tr><td>%R</td><td></td>
    <td>relative support with insertions as a percentage</td></tr>
<tr><td>%e</td><td></td>
    <td>additional evaluation measure</td></tr>
<tr><td>%E</td><td></td>
    <td>additional evaluation measure as a percentage</td></tr>
</table>

<p>All format specifiers can be extended by an integer number between
the percent sign and the defining character, which specifies the number
of decimal digits to be printed (expect those that refer to integer
numbers, like the number of items and the absolute support, for which
such a number of digits is ignored). If no such number is given,
(up to) six significant digits are reported.</p>

<p>The default additional information output format is for item sets
"<tt>  (%S)</tt>". That is, the relative support of the item set is
printed with (up to) six significant digits, enclosed in parentheses.
Two spaces separate the additional information from the last item
in the set. The default format is automatically changed to
"<tt>  (%a)</tt>" if the minimum support (option <tt>-s</tt>)
is given as a negative number (absolute support), so that the output
is consistent with the support threshold.</p>

<!-- =============================================================== -->
<hr>

<h4><a name="pspout">Format of a Pattern Spectrum</a></h4>

<p>A pattern spectrum collects the number of found frequent item sets
sub-divided by the size and the support of the item sets. Pattern
spectra (together with surrogate data/randomization methods) can be
useful to determine the statistical significance of found frequent
item sets. Details can be found in the papers
<a href="#Picado-Muino_et_al_2013">[Picado-Muino <i>et al.</i> 2013]</a>
and <a href="#Torre_et_al_2013">[Torre <i>et al.</i> 2013]</a>.</p>

<p>My RElim implementation can be instructed to collect and write a
pattern spectrum with the option <tt>-P</tt>, which takes the name
of the file to which the patterns spectrum is to be written as a
parameter.</p>

<p>A pattern spectrum is written as a list of (size, support, count)
triplets. The output file is a simple text file that contains one
triplet per line, with the three numbers separated by spaces.
For example, for the input file <tt>test1.tab</tt> (see
<a href="#transin">this section</a>) the pattern spectrum is
(with default option settings):</p>

<p><tt>
1 3 1<br>
1 6 1<br>
1 7 3<br>
2 1 2<br>
2 3 1<br>
2 4 4<br>
2 5 1<br>
2 6 1<br>
3 1 2<br>
3 2 1<br>
3 3 2<br>
3 4 1<br>
4 2 1
</tt></p>

<p>The first column contains the different sizes of item sets, the
second column the difference support values, and the third column
the number of item sets found for the corresponding (size, support)
combination. For example, the sixth row indicates that there are
four frequent item sets with two items and support 4. Note that in
a pattern spectrum the support is always given as absolute support,
that is, as a number of transactions.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="copying">Copying</a></h3>

<p>RElim -
   find frequent item sets with the RElim algorithm<br>
   copyright &copy; 2005-2013  Christian Borgelt</p>

<p>This program is free software; you can redistribute it and/or
modify it under the terms of the
<a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">
GNU Lesser (Library) General Public License</a>
as published by the
<a href="http://www.fsf.org">Free Software Foundation</a>.</p>

<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
<a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">
GNU Lesser (Library) General Public License</a>
for more details.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="download">Download</a></h3>

<p><a href="http://www.borgelt.net/relim.html">
Download page</a> with most recent version.</p>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="contact">Contact</a></h3>

<table border=0 cellpadding=1 cellspacing=4>
<tr><td valign="top">E-mail:</td><td style="width:10px"></td>
    <td><a href="mailto:christian@borgelt.net">
        christian@borgelt.net</a><br>
        <a href="mailto:christian.borgelt@softcomputing.es">
        christian.borgelt@softcomputing.es</a></td></tr>
<tr><td valign="top">Snail mail:</td><td></td>
    <td><a href="http://www.softcomputing.es/metaspace/portal/ecsc/38?pms=1,125,38007,view,normal,0&amp;id=13">
        Christian Borgelt</a><br>
        <a href="http://www.softcomputing.es/metaspace/portal/3/47-intelligent-data-analysis?pms=1,7,188003,view,normal,0">
        Intelligent Data Analysis and Graphical Models Research Unit</a><br>
        <a href="http://www.softcomputing.es/">
        European Center for Soft Computing</a><br>
        Edificio Cientifico-Tecnol&oacute;gico, 3<sup>a</sup> Planta<br>
        c/ Gonzalo Guti&eacute;rrez Quir&oacute;s s/n<br>
        33600 Mieres (Asturias)<br>
        Spain</td></tr>
<tr><td>Phone:</td><td></td>
    <td>+34 985 456545</td></tr>
<tr><td>Fax:</td><td></td>
    <td>+34 985 456699</td></tr>
</table>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<h3><a name="refs">References</a></h3>

<p>An overview of frequent item set mining can be found
in this survey paper:</p>

<ul style="list-style-type:disc">
<li><a name="Borgelt_2012"></a><b>Frequent Item Set Mining</b><br>
    Christian Borgelt<br>
    <i>Wiley Interdisciplinary Reviews:
    Data Mining and Knowledge Discovery</i> 2(6):437-456.<br>
    J.&nbsp;Wiley&nbsp;&amp;&nbsp;Sons, Chichester, United Kingdom 2012<br>
    <a href="http://dx.doi.org/10.1002/widm.1074">doi:10.1002/widm.1074</a>
    <a href="http://onlinelibrary.wiley.com/doi/10.1002/widm.1074/abstract">wiley.com</a><br>
    (20&nbsp;pages)</li>
</ul>

<p>A description of some implementation aspects of the RElim algorithm
can be found in the following papers:</p>

<ul style="list-style-type:disc">
<li><a name="Borgelt_2010"></a><b>Simple Algorithms
    for Frequent Item Set Mining</b><br>
    Christian Borgelt<br>
    Chapter 16 of: J.&nbsp;Koronacki, Z.W.&nbsp;Raz, S.T.&nbsp;Wierzchon,
    and J.K.&nbsp;Kacprzyk (eds.)<br>
    <i><a href="http://www.springer.com/engineering/book/978-3-642-05178-4">Advances in Machine Learning II
    (Studies in Computational Intelligence 263)</a></i>,
    351-369<br>
    Springer-Verlag, Berlin, Germany 2010<br>
    <a href="http://dx.doi.org/10.1007/978-3-642-05179-1_16">doi:10.1007/978-3-642-05179-1_16</a>
    <a href="http://www.springerlink.com/content/rkl3p0t8864217l2/">www.springerlink.com</a><br>
    <a href="papers/simple.pdf">simple.pdf</a> (416 kb)
    <a href="papers/simple.ps.gz">simple.ps.gz</a> (261 kb)
    (18 pages)</li>
<li><a name="Borgelt_2005"></a><b>Keeping Things Simple:
    Finding Frequent Item Sets by Recursive Elimination</b><br>
    Christian Borgelt.<br>
    <i>Workshop Open Source Data Mining Software
       (OSDM'05, Chicago, IL)</i>, 66-70.<br>
    ACM Press, New York, NY, USA 2005<br>
    <a href="papers/relim.pdf">relim.pdf</a> (166 kb)
    <a href="papers/relim.ps.gz">relim.ps.gz</a> (122 kb)
    (5 pages)</li>
<li><a name="Borgelt_et_al_2005b"></a><b>Mining
    Fuzzy Frequent Item Sets</b><br>
    Xiaomeng Wang, Christian Borgelt, and Rudolf Kruse<br>
    <i>Proc. 11th Int. Fuzzy Systems Association
       World Congress (IFSA'05, Beijing, China)</i>, 528-533.<br>
    Tsinghua University Press and Springer-Verlag,
    Beijing, China, and Heidelberg, Germany 2005.<br>
    <a href="papers/ifsa_05.pdf">ifsa_05.pdf</a> (107 kb)
    <a href="papers/ifsa_05.ps.gz">ifsa_05.ps.gz</a> (70 kb)
    (6 pages)</li>
<li><a name="Borgelt_et_al_2005b"></a><b>Fuzzy Frequent
    Pattern Discovery Based on Recursive Elimination</b><br>
    Xiaomeng Wang, Christian Borgelt, and Rudolf Kruse<br>
    <i>Proc. 4th IEEE Int. Conf. on Machine Learning and Applications
    (ICMLA'05, Los Angeles, CA)</i>, 391-396.<br>
    IEEE Press, Piscataway, NJ, USA 2005<br>
    <a href="papers/icmla_05.pdf">icmla_05.pdf</a> (159 kb)
    <a href="papers/icmla_05.ps.gz">icmla_05.ps.gz</a> (140 kb)
    (6 pages)</li>
</ul>

<p>The use of pattern spectra to evaluate the statistical significance
of found frequent item sets is explained in these papers:</p>

<ul style="list-style-type:disc">
<li><a name="Picado-Muino_et_al_2013"></a><b>Finding Neural Assemblies
    with Frequent Item Set Mining</b><br>
    David Picado-Mui&ntilde;o, Christian Borgelt, Denise Berger,
    George Gerstein, and Sonja Gr&uuml;n<br>
    <i>Frontiers in Neuroinformatics</i> 7:article&nbsp;9<br>
    Frontiers Media, Lausanne, Switzerland 2013<br>
    <a href="http://dx.doi.org/10.3389/fninf.2013.00009">doi:10.3389/fninf.2013.00009</a>
    <a href="http://www.frontiersin.org/Neuroinformatics/10.3389/fninf.2013.00009/abstract">frontiersin.org</a><br>
    <a href="papers/accfim.pdf">accfim.pdf</a> (1797 kb)
    <a href="papers/accfim.ps.gz">accfim.ps.gz</a> (772 kb)
    (14&nbsp;pages)</li>
<li><a name="Torre_et_al_2013"></a><b>Statistical Evaluation
    of Synchronous Spike Patterns extracted by Frequent Item
    Set Mining</b><br>
    Emiliano Torre, David Picado-Mui&ntilde;o, Michael Denker,
    Christian Borgelt, and Sonja Gr&uuml;n<br>
    <i>Frontiers in Computational Neuroscience</i>,
    7:article&nbsp;132<br>
    Frontiers Media, Lausanne, Switzerland 2013<br>
    <a href="http://dx.doi.org/10.3389/fninf.2013.00132">doi:10.3389/fninf.2013.00132</a>
    <a href="http://www.frontiersin.org/Computational_Neuroscience/10.3389/fncom.2013.00132/abstract">frontiersin.org</a><br>
    (13&nbsp;pages)</li>
</ul>

<table width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td style="width:95%" align="right">
        <a href="#top">back to the top</a></td>
    <td style="width:5px"></td>
    <td><a href="#top"><img src="up.gif" alt="top"></a></td></tr>
</table>

<!-- =============================================================== -->
<p><img src="line.gif" alt="" height=7 width=704></p>

<address>&copy; 2005-2013
<a href="mailto:christian@borgelt.net">Christian Borgelt</a>
</address>
</body>
</html>
